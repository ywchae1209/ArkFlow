# Overall Note

1. 분류기능
   - 임의의 Json 데이터가 어떠한 규칙으로 검증/변환되어야 할 지 정하기 위한 기능

   - 전체 성능을 좌우하는 가장 Critical한 부분.

   - 생각중인 구현방안:  
      Key의 조합을 찾는 방법과 Value조합을 만들고, Trie Tree 검색을 하도록 할까 생각 중.

   - 분류의 결과가 하나의 검증규칙에 대응되는 것이 최선이겠으나, 여러개의 검증규칙에 대응될 수 있을 것으로 가정,

2. 검증기능
   - 지정된 검증 규칙으로 주어진 Json 데이터가 규칙에 따르는 지 검증

   - 얼마나 유용한 지에 가장 중요한 기능

   - 최대한 간단한 규칙을 제공하고, 문제조치를 위한 충실한 정보전달이 중요.  
     ( 검증규칙의 문법검증과 검증실패시, 내역을 최대한 세세히 제공하여 사용자(개발자)가 문제를 발견하고 조치하기 쉽게하는 것.)

   - 구현 방향  
     검증대상 Json구조를 재사용할 수 있도록 (--> Rule 작성이 쉽도록) 하고,   
     자유문법을 제공해서, 최대한 다양한 검증요건을 수용하도록.

   - 좀더 고민할 일.   
     Array 특히 Recursive한 경우에 어떤 map-reduce류의 검증방식이 필요하지 않을까.   
     (일반화를 더 넑게 하기 위해서)

3. 변환기능
   - 검증된 Json데이터를 다른 Schema로 변환하는 것.

   - N-Tree to N-Tree  변환이어서, 일반해를 구하는 것이 매우 어려움.   
     ( 일정한 제한을 가해야 할 듯.)

   - 구현할 내용과 방향   
     1 원본 구조에서 특정 Node를 지정하는 것과 대상 구조에 Mapping하는 것   
     2. Mapping전 추출/변형/조합 기능 필요할 수 있음.   

      json-path 문법을 확장하여 원본 Node지정하는 것에서 시작할 예정.   
      ( 좀 복잡해도, 일반문법을 수용하는 게.. 사용하기 쉬울테니.   
      단, mapping을 위해 json-path에 없는 기능을 추가해야 할 듯. )   

---------------------------

### 업계에서 쓰이는 용어들과의 미묘한 차이   
   - Format/ Formattting	=> Json을 예쁘게 보여 주는 정도의 의미로 많이 씀
   - Convert/Converting	=> (구조자체를 바꾼다기 보다는 Word/ PDF/ Excel등으로) ) 표현형식 변환의 의미로 많이 씀.

     우리
     - Format :: 문서의 내용과 구조가 맞는 지 점검하는 것.
     - Syntax :: 문서의 구성요소(Node)들이 지정한 규칙과 맞는지 점검하는 것.
     - Convert :: 구조의 변환 ( Schema to Schema 변환)



------------------

# 설명
## JsonValidator
JSON 데이터가 특정한 규칙을 지키는 지 여부를 점검하는 기능

### 특징
1. Json의 데이터 구조( N-depth Tree)를 그대로 규칙에 반영할 수 있음.
2. Json의 구성요소( Object, Array, Value)별로 규칙점검이 이루어짐.
3. 점검오류/실패는 점검규칙 생성시, 규칙오류( Rule-Syntax-Error)와 점검시 실패( Evaluation-Fail)로 구분됨.
4. 점검오류/실패는 점검규칙과 마찬가지로 Tree 구조를 가지며, 그 내역을 Json으로 제공함.

------------------

### 점검 규칙 설명


------------------



#### Value Validation Rule


------------------


##### Value Validation 사례

------------------

- "_longerThan(8) && _shorterThan(20)"  
   8~20길이의 문자열. 논리 연산자(&&, ||를 사용할 수 있음)   
   _(underscore)로 시작하는 함수들은 문자열값에 적용하는 함수.


- "gt(100) && lt(200) || gt(200) && lt(300)"   
   100~200 또는 200~300인 숫자값  
   &&연산자가 ||연산자보다 우선순위가 높음.


- "_gt(100) && (_lt(200) || lt(200))"   
  규칙들은 ()를 이용해서 우선순위 조정하거나, 복합 구성을 할 수 있음.  
  _gt(100)은 대상값이 문자열인데, 숫자로 바꾸어서 비교하라는 의미.


- "_oneOf(this, is, go\'od, 'my holiday')"   
  공백없는 문자열은 그대로 사용하면 되고,   
  공백을 쓸 경우,  '(single-quote)를 사용.  
  문자열에서 '(single-quote)를 사용할 때는 \(back-slash)로 escape 함.

  


##### Value Validation에서 사용할 수 있는 함수들.


------------------

	_any                : 항상 참
	_between(100,200)   : 100~200사이의 정수를 표현하는 문자열
	_between0(100, 200) : 100~200사이의 실수를 표현하는 문자열
	_charsIn(가, 나, 다) : 가, 나, 다로만 이루어진 문자열
	_date(${yyyy}-${mm}-${dd} : 2024-02-12 와 같은 형식의 문자열
	_digit               : 숫자(0-9)로만 이루어진 문자열
	_digitOr(a,b,c)      : 숫자와 a, b, c로만 이루어진 문자열
	_gt(100)             : 100보다 큰 정수를 표현하는 문자열
	_gt0(100)            : 100보다 큰 실수를 표현하는 문자열
	_gte(100)            : 1000보다 크거나 같은 정수를 표현하는 문자열
	_gte0(100)           : 1000보다 크거나 같은 실수를 표현하는 문자열
	_isString            : 문자열인 경우 참. 
	_length(10)          : 길이가 10인 문자열
	_longerThan(10)      : 길이가 10보다 긴 문자열
	_lt(999)             : 999보다 작은 정수를 표현하는 문자열
	_lt0(999)            : 999보다 작은 실수를 표현하는 문자열
	_lte(999)            : 999보다 작거나 같은 정수를 표현하는 문자열
	_lte0(999)           : 999보다 작거나 같은 실수를 표현하는 문자열
	_oneOf(this, is)     : this 또는 is
	_regex([0-9].*)      : 정규표현식에 부합하는 문자열 (사례는 숫자로 시작하는 문자열)
	_shorterThan(10)     : 길이가 10보다 작은 문자열
	between(10, 100)     : 10~100 사이의 정수
	between0(10, 100)    : 10~100 사이의 실수
	gt(10)               : 10 보다 큰 정수
	gt0(10)              : 10 보다 큰 실수
	gte(10)              : 10 보다 크거나 같은 정수
	gte0(10)             : 10 보다 크거나 같은 실수
	lt(10)               : 10 보다 작은 정수
	lt0(10)              : 10 보다 작은 실수
	lte(10)              : 10 보다 작거나 같은 정수
	lte0(10)             : 10 보다 작거나 같은 실수

------------------

